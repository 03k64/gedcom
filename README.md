# GEDCOM

`gedcom` is a simple application that takes a GEDCOM file as input and outputs a
JSON file containing data compatible with the FindMyPast relation API.

## Pre-Requisites

In order to run `gedcom` you will need to install Rust, the easiest way is to go
to [the rustup site](https://rustup.rs/) and follow the instructions for your
operating system. Once you have installed Rust you will also need to install
[`grcov`](https://github.com/mozilla/grcov) in order to generate a test coverage
report. If you have first installed Rust you can do this by running
`cargo install grcov`.

## Compiling and Running the Application

Rust is a compiled language, accordingly you must first compile `gedcom` before
using it. To compile a development build of `gedcom` you can use the command
`cargo build`, to compile an optimised build for benchmarking you should instead
run `cargo build --release`.

You can then run the compiled binary in one of two ways, either way you need to
provide two arguments using the `-i` and `-o` flags. The `-i` flag expects an
argument consisting of the path to the GEDCOM input file. The `-o` flag expects
an argument consisting of the path to write the JSON output file.

### Option 1

You can run the binary using `cargo` in development mode using
`cargo run -- -i <path/to/input.ged> -o <path/to/desired.json>` or in release
mode using
`cargo run --release -- -i <path/to/input.ged> -o <path/to/desired.json>`.

### Option 2

You can run the development binary directly using
`target/debug/gedcom -i <path/to/input.ged> -o <path/to/desired.json>` or the
release binary directly using
`target/release/gedcom -i <path/to/input.ged> -o <path/to/desired.json>`.

For the purposes of benchmarking the release binary should be first compiled and
then run using Option 2 above to avoid any overhead incurred by running through
`cargo`.

## Running the Tests and Generating a Coverage Report

Tests live alongside the code in most source files. They can be found at the end
of the source code in a separate `tests` module. The `tests` module is preceded
by a `#[cfg(test)]` directive that ensures these modules are _not_ compiled into
optimised release builds.

The tests themselves may be run using `cargo test`. A coverage report may be
generated by running the `generate-coverage-report.sh` script. This script uses
`cargo clean` to first remove _all previously compiled binaries_. This step is
necessary to re-compile the development binary with specific options needed to
allow for coverage generation to be completed. You _will_ need to re-compile any
release builds before running benchmarks as outlined above.

## Running the Micro-Benchmarks

The [Criterion library](https://bheisler.github.io/criterion.rs/book/index.html)
was used in development to ensure performance regressions did not occur. To this
end a small benchmark can be found in `benches/small_benchmark.rs`. Criterion
acts as a test harness, but also produces output in the following format that
allows regressions to be tracked between changes with a degree of statistical
significance:

```shell
gedcom_to_relation_json ONE_NODE
                        time:   [295.56 us 301.15 us 307.26 us]
Found 5 outliers among 100 measurements (5.00%)
  4 (4.00%) high mild
  1 (1.00%) high severe

gedcom_to_relation_json THREE_NODE
                        time:   [510.15 us 517.52 us 525.58 us]
Found 14 outliers among 100 measurements (14.00%)
  8 (8.00%) high mild
  6 (6.00%) high severe

gedcom_to_relation_json SIBLING
                        time:   [608.85 us 643.60 us 687.81 us]
Found 12 outliers among 100 measurements (12.00%)
  3 (3.00%) high mild
  9 (9.00%) high severe
```

## Project Structure

The project is split into two parts, or in Rust parlance, crates. The
application crate, consisting only of the file `src/main.rs`, handles execution
of the program. The library crate consisting of all other files in the `src`
directory, with an entrypoint in `src/lib.rs` provides all underlying GEDCOM
specific functionality. The library crate is in turn largely organised into two
submodules, `models` and `parser`.

### Dependencies and their Uses

Here is a brief overview of the third-party crates used in this library. These
crates are declared in the manifest file `Cargo.toml` under the `[dependencies]`
section.

|Crate|Description|Official Site / Documentation URL|
|---|---|---|
|`chrono`|A Date & Time library|https://docs.rs/chrono/0.4.11/chrono/|
|`clap`|Command-Line Argument Parser|https://clap.rs/|
|`lazy_static`|A macro for declaring lazily evaluated statics|https://docs.rs/lazy_static/1.4.0/lazy_static/|
|`nom`|Nom is a Parser-combinator library|https://docs.rs/nom/6.0.0-alpha1/nom/index.html|
|`regex`|Regular expressions library|https://docs.rs/regex/1.3.7/regex/|
|`serde`|Serialization and deserialization framework|https://serde.rs/|
|`serde_json`|JSON serialization and deserialization using `serde`|https://docs.serde.rs/serde_json/|
|`serde_repr`|Serialization and deserialization of enumerated types using user-specified representation|https://docs.rs/serde_repr/0.1.5/serde_repr/|
